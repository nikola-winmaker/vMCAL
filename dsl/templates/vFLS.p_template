{%- set size_parameter = module.parameters|selectattr('name', 'equalto', 'size')|first -%}
{%- set start_address_parameter = module.parameters|selectattr('name', 'equalto', 'start_address')|first -%}
{%- set otp_parameter = module.parameters|selectattr('name', 'equalto', 'otp')|first -%}
{%- set sim_events = module.events -%}
{%- set sim_actions_dict = {} -%}

{#-cc Process acctions for simulation if any -#}
{% for events in sim_events %}
    {% for event in events.events %}
        {% set actions_list = [] %}
        {% for cycle in event.cycles %}
            {% for action in cycle.actions %}
                {% set action_dict = {} %}
                {% if action.__class__.__name__ == 'Delay' %}
                    {% set _ = action_dict.update({cycle.index: {'type': 'DELAY', 'time': action.time}}) %}
                {% elif action.__class__.__name__ == 'Error' %}
                    {% set _ = action_dict.update({cycle.index: {'type': 'ERROR', 'message': action.message, 'propagation_time': action.propagation_time}}) %}
                {% elif action.__class__.__name__ == 'Timeout' %}
                    {% set _ = action_dict.update({cycle.index: {'type': 'TIMEOUT', 'duration': action.duration}}) %}
                {% endif %}
                {% set _ = actions_list.append(action_dict) %}
            {% endfor %}
            {% set _ = sim_actions_dict.update({event.name: actions_list}) %}
        {% endfor %}
    {% endfor %}
{% endfor %}


{% set vfls_callbacks = [('', 'vFls_Init'), ('address, data', 'vFls_Write'),
                         ('address, length', 'vFls_Erase'), ('', 'vFls_GetStatus'),
                         ('', 'vFls_GetJobResult'), ('', 'vFls_Cancel'),
                         ('address, target_address_ptr, length', 'vFls_Read'), ('mode', 'vFls_SetMode')] %}
import ctypes
import pickle 
import time 

# Autogenerated from {{module.name}}.p_template file
class vFlash:
    def __init__(self, app_dll):
        # reference to DLL file
        self.dll = app_dll

        # Flash parameters
        self.flash_size           = {{size_parameter.value          | format_hex }}
        self.flash_start_addr     = {{start_address_parameter.value | format_hex }}
        self.flash_otp_start_addr = {{otp_parameter.value.values[0] | format_hex }}
        self.flash_otp_size       = {{otp_parameter.value.values[1] | format_hex }}
        self.flash_data = [0XFF] * self.flash_size
        self.start_sim_time = 0
        self.sim_enable = False

        # Create callbacs for FLS
        {% for callback_type, callback_name in vfls_callbacks %}
        self.{{callback_name}}_cbk = None
        {% endfor %}

        # create a list to store history data
        self.history_data = []
        # try to load previosly saved flash data
        try:
            # Load the variable back into memory
            with open('flash_data.pkl', 'rb') as f:
                self.flash_data = pickle.load(f)
        except:
            pass

        self.flash_sim_actions = {{ sim_actions_dict }}

    def apply_sim_event(func_name):
        def decorator_function(func):
            def wrapper_function(*args, **kwargs) -> int:
                result = 0
                events = []
                if func_name in args[0].flash_sim_actions:
                    event_list = args[0].flash_sim_actions[func_name]
                    for event_dict in event_list:
                        cycle_num = list(event_dict.keys())[0]
                        # check if event needs to be applied
                        if cycle_num == 0: # immediate apply
                            events.append(event_dict[cycle_num])
                            # get and remove event
                            event_list.remove(event_dict)
                        else:
                            start_sim_time = args[0].start_sim_time
                            current_time_ms = args[0].time_from_start()
                            print("*******************************************")
                            print(start_sim_time, cycle_num, current_time_ms)
                            print("*******************************************")

                            if current_time_ms  >= cycle_num:
                                events.append(event_dict[cycle_num])
                                if event_dict[cycle_num]['type'] != 'DELAY':
                                    propagation_time = event_dict[cycle_num]['propagation_time']
                                    if propagation_time == 0:
                                        # get and remove event
                                        event_list.remove(event_dict)
                                    else:
                                        if current_time_ms > cycle_num + propagation_time:
                                            # get and remove event
                                            event_list.remove(event_dict)
                                else:
                                    # get and remove event
                                    event_list.remove(event_dict)
                        break

                    for event in events:
                        if event['type'] == 'DELAY':
                            print(event['type'], event['time'])

                            time.sleep(event['time']/1000) # in ms
                            result = func(*args, **kwargs)
                        elif event['type'] == 'ERROR' :
                            print(event['type'], event['message'])
                            #time.sleep(10000) # in ms

                            result = 2

                    if len(events) == 0:
                        result = func(*args, **kwargs)                    

                return result
            return wrapper_function
        return decorator_function

    def simulation_enable(self):
        self.sim_enable = True
        self.start_sim_time = int(round(time.time() * 1000))

    def time_from_start(self):
        return int(round(time.time() * 1000)) - self.start_sim_time

    def write_flash(self, address, data, length=1):
        for i in range(length):
            self.flash_data[address+i] = data
        with open('flash_data.pkl', 'wb') as f:
            pickle.dump(self.flash_data, f)

    def read_flash(self, address, length=1):
        return self.flash_data[address : address+length-1]

{% for callback_type, callback_name in vfls_callbacks %}
    def set_{{ callback_name }}_callback(self):
        callback = self.dll.set_{{ callback_name }}_callback
        {% if callback_name in ['vFls_Write', 'vFls_Erase'] %}     
        callback.argtypes = [ctypes.CFUNCTYPE(ctypes.c_int32, ctypes.c_int, ctypes.c_int)]
        self.{{callback_name}}_cbk = ctypes.CFUNCTYPE(ctypes.c_int32, ctypes.c_int,  ctypes.c_int)(self.{{ callback_name }}_callback)
        {% elif callback_name == 'vFls_Read' %}
        callback.argtypes = [ctypes.CFUNCTYPE(ctypes.c_int32, ctypes.c_int, ctypes.POINTER(ctypes.c_byte), ctypes.c_int)]
        self.{{callback_name}}_cbk = ctypes.CFUNCTYPE(ctypes.c_int32, ctypes.c_int, ctypes.POINTER(ctypes.c_byte), ctypes.c_int)(self.{{ callback_name }}_callback)
        {% elif callback_name == 'vFls_SetMode' %}
        callback.argtypes = [ctypes.CFUNCTYPE(None, ctypes.c_int)]
        self.{{callback_name}}_cbk = ctypes.CFUNCTYPE(None, ctypes.c_int)(self.{{ callback_name }}_callback)
        {% elif callback_name in ['vFls_GetStatus', 'vFls_GetJobResult', 'vFls_Init'] %}
        callback.argtypes = [ctypes.CFUNCTYPE(ctypes.c_int32)]
        self.{{callback_name}}_cbk = ctypes.CFUNCTYPE(ctypes.c_int32)(self.{{ callback_name }}_callback)
        {% else %}
        callback.argtypes = [ctypes.CFUNCTYPE(None)]
        self.{{callback_name}}_cbk = ctypes.CFUNCTYPE(None)(self.{{ callback_name }}_callback)
        {% endif %}

        callback(self.{{callback_name}}_cbk)
{% endfor %}

    def set_callbacks(self):
    {% for callback_type, callback_name in vfls_callbacks %}
        self.set_{{ callback_name }}_callback()
    {% endfor %}

{% for callback_type, callback_name in vfls_callbacks %}
    @apply_sim_event('{{callback_name.split('_')[1]}}')
    def {{ callback_name }}_callback(self{% if callback_type %}, {{ callback_type }}{% endif %}) {% if callback_name in ['vFls_GetStatus', 'vFls_Init', 'vFls_GetJobResult', 'vFls_Write', 'vFls_Read', 'vFls_Erase'] %} -> int{% endif %}:
        from datetime import datetime
        # get current time and format it
        current_time = datetime.now().strftime("%Y-%m-%d %H:%M:%S")
        # add data to history list

        {% if callback_name == 'vFls_Write' %}
        self.write_flash(address, data)
        log = f"{current_time} - Write: Address: {hex(address)}, Data: {hex(data)}"
        {% elif callback_name == 'vFls_Erase' %}
        self.write_flash(address, 0xff, length)
        log = f"{current_time} - Erase: Address: {hex(address)}, Length: {hex(length)}"
        {% elif callback_name == 'vFls_Read' %}
        target_address_ptr = self.read_flash(address, length)
        log = f"{current_time} - Read: Address: {hex(address)}, Length: {hex(length)}"
        {% else %}
        log = f"{current_time} - {{callback_name}}"
        {% endif %}

        {% if callback_name in ['vFls_Read', 'vFls_Write', 'vFls_Erase'] %}
        self.history_data.append(log)
        {% endif %}

        {% if callback_name == 'vFls_GetStatus' %}
        if ret in ['Error', 'Timeout']:
            return 0 # 0 uninit, 1 idle, 2 busy, 3 busy or idle
        else:
            return 1 # 0 uninit, 1 idle, 2 busy, 3 busy or idle
        {% elif callback_name == 'vFls_GetJobResult' %}
        if ret in ['Error', 'Timeout']:
            return 1 # MEMIF_JOB_FAILED
        else:
            return 0 # JOB OK
        {% elif callback_name in ['vFls_Read', 'vFls_Write', 'vFls_Erase', 'vFls_Init'] %}
        return 0
        {% endif %}
        
{% endfor %}
