{%- set size_parameter = module.parameters|selectattr('name', 'equalto', 'size')|first -%}
{%- set start_address_parameter = module.parameters|selectattr('name', 'equalto', 'start_address')|first -%}
{%- set otp_parameter = module.parameters|selectattr('name', 'equalto', 'otp')|first -%}
{%- set sim_events = module.events -%}
{%- set sim_actions_dict = {} -%}

{#-cc Process acctions for simulation if any -#}
{% for events in sim_events %}
    {% for event in events.events %}
        {% set actions_list = [] %}
        {% for cycle in event.cycles %}
            {% for action in cycle.actions %}
                {% set action_dict = {} %}
                {% if action.__class__.__name__ == 'Delay' %}
                    {% set _ = action_dict.update({cycle.index: {'type': 'DELAY', 'time': action.time}}) %}
                {% elif action.__class__.__name__ == 'Error' %}
                    {% set _ = action_dict.update({cycle.index: {'type': 'ERROR', 'message': action.message, 'propagation_time': action.propagation_time}}) %}
                {% elif action.__class__.__name__ == 'Timeout' %}
                    {% set _ = action_dict.update({cycle.index: {'type': 'TIMEOUT', 'duration': action.duration}}) %}
                {% endif %}
                {% set _ = actions_list.append(action_dict) %}
            {% endfor %}
            {% set _ = sim_actions_dict.update({event.name: actions_list}) %}
        {% endfor %}
    {% endfor %}
{% endfor %}


{% set vfls_callbacks = [('', 'vFls_Init'), ('address, data', 'vFls_Write'),
                         ('address, length', 'vFls_Erase'), ('', 'vFls_GetStatus'),
                         ('', 'vFls_GetJobResult'), ('', 'vFls_Cancel'),
                         ('address, target_address_ptr, length', 'vFls_Read'), ('mode', 'vFls_SetMode')] %}
import ctypes
import pickle 
import time 
import sys

sys.path.insert(0, '../test_env')
from vMCAL import v_fls_sim_event

# Autogenerated from {{module.name}}.p_template file
class vFlash:
    """
    A class that provides FLS callbacks for a DLL Application, allowing a C application
    to call Python vFLS functions.
    """
    def __init__(self, app_dll):
        # reference to DLL file
        self.dll = app_dll

        # Flash parameters
        self.flash_size           = {{size_parameter.value          | format_hex }}
        self.flash_start_addr     = {{start_address_parameter.value | format_hex }}
        self.flash_otp_start_addr = {{otp_parameter.value.values[0] | format_hex }}
        self.flash_otp_size       = {{otp_parameter.value.values[1] | format_hex }}
        self.flash_data = [0XFF] * self.flash_size
        self.start_sim_time = 0
        self.sim_enable = False

        # Create callbacs for FLS
        {% for callback_type, callback_name in vfls_callbacks %}
        self.{{callback_name}}_cbk = None
        {% endfor %}

        # create a list to store history data
        self.history_data = []
        # try to load previosly saved flash data
        try:
            # Load the variable back into memory
            with open('flash_data.pkl', 'rb') as f:
                self.flash_data = pickle.load(f)
        except:
            pass

        # User simulation events provided trough DSL specification
        self.flash_sim_actions = { {% for key, value in sim_actions_dict.items() %} 
                                   '{{ key }}': {{ value }},
                                 {% endfor %}
                                 }

    def simulation_enable(self):
        self.sim_enable = True
        self.start_sim_time = int(round(time.time() * 1000))

    def time_from_start(self):
        return int(round(time.time() * 1000)) - self.start_sim_time

    def write_flash(self, address, data, length=1):
        for i in range(length):
            self.flash_data[address+i] = data
        with open('flash_data.pkl', 'wb') as f:
            pickle.dump(self.flash_data, f)

    def read_flash(self, address, length=1):
        return self.flash_data[address : address+length-1]

{% for callback_type, callback_name in vfls_callbacks %}
    def set_{{ callback_name }}_callback(self):
        callback = self.dll.set_{{ callback_name }}_callback
        {% if callback_name in ['vFls_Write', 'vFls_Erase'] %}     
        callback.argtypes = [ctypes.CFUNCTYPE(ctypes.c_int32, ctypes.c_int, ctypes.c_int)]
        self.{{callback_name}}_cbk = ctypes.CFUNCTYPE(ctypes.c_int32, ctypes.c_int,  ctypes.c_int)(self.{{ callback_name }}_callback)
        {% elif callback_name == 'vFls_Read' %}
        callback.argtypes = [ctypes.CFUNCTYPE(ctypes.c_int32, ctypes.c_int, ctypes.POINTER(ctypes.c_byte), ctypes.c_int)]
        self.{{callback_name}}_cbk = ctypes.CFUNCTYPE(ctypes.c_int32, ctypes.c_int, ctypes.POINTER(ctypes.c_byte), ctypes.c_int)(self.{{ callback_name }}_callback)
        {% elif callback_name == 'vFls_SetMode' %}
        callback.argtypes = [ctypes.CFUNCTYPE(None, ctypes.c_int)]
        self.{{callback_name}}_cbk = ctypes.CFUNCTYPE(None, ctypes.c_int)(self.{{ callback_name }}_callback)
        {% elif callback_name in ['vFls_GetStatus', 'vFls_GetJobResult', 'vFls_Init'] %}
        callback.argtypes = [ctypes.CFUNCTYPE(ctypes.c_int32)]
        self.{{callback_name}}_cbk = ctypes.CFUNCTYPE(ctypes.c_int32)(self.{{ callback_name }}_callback)
        {% else %}
        callback.argtypes = [ctypes.CFUNCTYPE(None)]
        self.{{callback_name}}_cbk = ctypes.CFUNCTYPE(None)(self.{{ callback_name }}_callback)
        {% endif %}

        callback(self.{{callback_name}}_cbk)
{% endfor %}

    def set_callbacks(self):
        """
        Sets FLS callbacks for the C application to call.
        """
    {% for callback_type, callback_name in vfls_callbacks %}
        self.set_{{ callback_name }}_callback()
    {% endfor %}

{% for callback_type, callback_name in vfls_callbacks %}
    @v_fls_sim_event('{{callback_name.split('_')[1]}}')
    def {{ callback_name }}_callback(self{% if callback_type %}, {{ callback_type }}{% endif %}) {% if callback_name in ['vFls_GetStatus', 'vFls_Init', 'vFls_GetJobResult', 'vFls_Write', 'vFls_Read', 'vFls_Erase'] %} -> int{% endif %}:
        """
        vFLS callback function for FLS {{callback_name.split('_')[1]}} that can be called by the C application.
        """
        from datetime import datetime
        # get current time and format it
        current_time = datetime.now().strftime("%Y-%m-%d %H:%M:%S")
        # add data to history list

        {% if callback_name == 'vFls_Write' %}
        self.write_flash(address, data)
        log = f"{current_time} - Write: Address: {hex(address)}, Data: {hex(data)}"
        {% elif callback_name == 'vFls_Erase' %}
        self.write_flash(address, 0xff, length)
        log = f"{current_time} - Erase: Address: {hex(address)}, Length: {hex(length)}"
        {% elif callback_name == 'vFls_Read' %}
        target_address_ptr = self.read_flash(address, length)
        log = f"{current_time} - Read: Address: {hex(address)}, Length: {hex(length)}"
        {% else %}
        log = f"{current_time} - {{callback_name.split('_')[1]}}"
        {% endif %}

        {% if callback_name in ['vFls_Read', 'vFls_Write', 'vFls_Erase', 'vFls_Init'] %}
        self.history_data.append(log)
        {% endif %}

        {% if callback_name == 'vFls_GetStatus' %}
        return 1 # 0 uninit, 1 idle, 2 busy, 3 busy or idle
        {% elif callback_name == 'vFls_GetJobResult' %}
        return 0 # JOB OK
        {% elif callback_name in ['vFls_Read', 'vFls_Write', 'vFls_Erase', 'vFls_Init'] %}
        return 0
        {% endif %}
        
{% endfor %}
